<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<script type="application/javascript">

//
//En JS las funciones son OBJETOS
//asociados siempre a otros objetos
//

//Los nombres de las funciones serán verbos
//Utilizando camel case

//En JS las funciones no indican si devuelven algo o no
//No existe la palabra reservada void
function saludar(){
    console.log("¡Hola!")
}

//Invocamos una funcion utilizando su nombre y los paréntesis
saludar();

//Las funciones pueden recibir parámetros
//No se indica el tipo (faltaría más)
function sumar(s1, s2){
    console.log(s1+s2)
} 

sumar(10,20)
sumar(10, "Bicicleta")
sumar(10, true)

//Podemos invocar una función con el número de parámetros que nos de la gana
sumar()          //NaN
sumar(1)         //NaN
sumar(1,2)       //3
sumar(1,2,3)     //3
sumar(1,2,3,4)   //3
sumar(1,2,3,4,5) //3

//Dentro de una funcion disponemos del array 'arguments' que
//almacena los parámetros recibidos
console.log("============================")
function sumarNumeros(){
    //console.log(arguments)

    let total = 0
    for(let a=0; a<arguments.length; a++){
        total = total + arguments[a];
    }
    console.log("Suma:"+total)
}

sumarNumeros()
sumarNumeros(1)
sumarNumeros(1,2)
sumarNumeros(1,2,3)
sumarNumeros(1,2,3,4)
sumarNumeros(1,2,3,4,5)

console.log("============================")
function sumarNumerosBis(...numeros){
    let total = 0
    for(let a=0; a<numeros.length; a++){
        total = total + numeros[a];
    }
    return total;
}

console.log("sumarNumerosBis:"+sumarNumerosBis(1,2,3,4,5,6,7,8,9))

/*
function f1(...args) {
 return args.reduce((p,c) => { return p + c })
}
console.log("Movida:"+f1(1,2,3,4,5))
*/

//Las funciones pueden devolver un valor
console.log("============================")
function restar(n1, n2){
    let resta = n1-n2
    return resta
}

let resta = restar(10,5)
console.log(resta)

console.log(restar(50,10))

//Todas las funciones devuelven algo, aunque sea 'undefined'
//Esto no tiene sentido pero tampoco falla:
let v1 = sumar(20,30)
console.log(v1) //undefined

//
//Desde ES6 se pueden utilizar valores popr defecto para los parámetros
//
console.log("============================")
function ejemplo(dato1=100, dato2=200){
    console.log(dato1+dato2);
}

ejemplo(10,50) //60
ejemplo(50)    //250
ejemplo()      //300

//
//Funciones anidadas/nested function/closures
//
console.log("============================")
function nido(){

    console.log("Ejecutando funcion nido...")

    function pajaro(){
        console.log("Ejecutando función pájaro...")
    }

    pajaro()

}

nido()
//Normalmente no podemos invocar una función anidada desde fuera del nido
//pajaro() //Zasca


//
//Las funciones en JS son OBJETOS
//Si son objetos entonces podemos guardarlas en variables
//Normalmente guardaremos una función en una variable para pasarla por parámetro a otra función
//La función que recibe el parámetros será la que la incoque
//
console.log("============================")

function dividir(n1, n2){
    return n1/n2
}

//Guardando una función anónima en una variable
let dividir2 = function(n1, n2){
    return n1/n2
}

console.log( dividir(100,3) )

//Para invocar una función que hemos referenciado con una variable usamos el nombre
//de la variable seguida de parentesis

console.log( dividir2 ) //sale la función
console.log( dividir2(200, 4) ) //50

//En JS, tenga sentido o no, es sintácticamente correcto usar cualquier variable con los
//parentesis
let x = 100
//Pero solo funciona si el contenido de la variable es una referencia a una función
//x() //Zasca!

//
//Creando una función con el prototipo Function
//
console.log("============================")
let dividir3 = new Function("n1","n2","return n1/n2")
/*
Sería equivalente a:
let dividir2 = function(n1, n2){
    return n1/n2
}
*/
console.log(dividir3)
console.log(dividir3(100,5))



</script>


<body>
    
    <h1>02_Funciones</h1>

</body>
</html>